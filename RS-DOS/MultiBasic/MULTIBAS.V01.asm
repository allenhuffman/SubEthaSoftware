** MultiBasic V1.01 by Terry Todd* Copyright (C) 1990 by Sub-Etha Software*TXTTAB EQU  $19       Points to beginning of Basic programVARTAB EQU  $1B       Where variables startFRETOP EQU  $21       Top of free memoryMEMSIZ EQU  $27       End of Basic memoryBINVAL EQU  $2BFPA0   EQU  $50LSTTXT EQU  $66CURLIN EQU  $68DEVNUM EQU  $6FTOPRAM EQU  $74       End of memorySKP2   EQU  $8CEXECJP EQU  $9DGETNCH EQU  $9FGETCCH EQU  $A5CHARAD EQU  $A6VD1    EQU  $D1NEWVAR EQU  $FDMODNUM EQU  $FFSNERR  EQU  $B277HIMEM  EQU  $6001LOMEM  EQU  $1401BLKNUM EQU  $E0E4BLKNM2 EQU  $FFA3*EXEC   LDX  #MODULE+1 This makes all the modules empty       LDB  MODULE    * Start at end of table       ABX            *EXEC1  LDA  ,-X       * Decrement X, get next block number       STA  BLKNUM    * Switch it in       STA  BLKNM2    *        CLR  HIMEM-1   * Store 0's       CLR  HIMEM     *       CLR  HIMEM+1   *       CMPX #MODULE+1 * See if all have been done       BNE  EXEC1     * Keep going if not*       LDD  TXTTAB    Copy current program to module 1       ADDD #$1FFF    * See if longer than 8k       CMPD VARTAB    * don't copy if so        BLO  EXEC2     *       LDX  TXTTAB    *       LDY  #HIMEM    *MOVEUP LDA  ,X+       * Get a byte from low       STA  ,Y+       * and store it in high        CMPX VARTAB    * see if at end of program       BNE  MOVEUP    * if not, keep  copying       LDX  #HIMEM    *       JSR  $ACF1     * readdress program*EXEC2  LDA  #33       STA  $B543     This makes basic always re-copy strings into memory*       LDA  #33       These move the stack starting at page 17       STA  $AC41     *(Make ramcheck start at "Fretop")       STA  $B4EF     *(Make memory check also see       LDA  #150      * "Fretop" instead of "Botstk")       STA  $B4EE     *       LDA  #17       *(New vector address of stack       STA  118       * stored in extra bytes 118 & 119)       LDA  #0        *       STA  119       *       LDA  #118      *(Set to look for stack in right       STA  $AD3C     * place)*       LDA  #158      These four will patch the Copy command bug       STA  $D3D8     *       LDA  #33       *       STA  $D3D9     *       LDA  #106      *       STA  $D3DA     *       LDA  #228      *       STA  $D3DB     ***These patch basic to look for end of basic at the new $FD location instead*of VARTAB*       LDA  #NEWVAR       STA  $89BA     These two patch the DEL command       STA  $89BE     *       STA  $8B44     These two patch the RENUM command       STA  $8B4D     *       STA  $A47F     This patches the CSAVE command       STA  $A4EC     This patches the CLOAD command       STA  $ACBB     These six patch where a line is added to a program       STA  $ACBD     *       STA  $ACC5     *       STA  $ACCE     *       STA  $ACE8     *       STA  $AD20     This patches the NEW command       STA  $CA1A     These two patch the SAVE command       STA  $CA2D     *       STA  $CAB3     These three patch the LOAD command       STA  $CABE     *       STA  $CAC0     *** These make ramcheck check against top of ram instead of top of cleared space*       LDD  #RAMCHK   *       STD  $ACD8     * This one patches where a line is added to a program       STD  $8B4F     * This one patches RENUM       LDD  #RAMCK1   *       STD  $CAA0     * This one patches loading a file** These patch in the new routines*       LDA  #$7E      Opcode for JMP       LDX  #INMSG       STA  $BDC5     Catch basic after saying 'IN xxxx'        STX  $BDC6       LDX  #LIST       STA  $B764     Catch basic going into LIST command       STX  $B765       LDX  #LISTX       STA  $B79C     Catch basic exiting LIST routine       STX  $B79D       LDX  #GO       STA  $AE88     Catch basic when receiving GO token       STX  $AE89       LDX  #RUN       STA  $AE81     Catch basic when receiving RUN token       STX  $AE82       LDX  #RETURN       STA  $AEDA     Catch basic at end of RETURN routine       STX  $AEDB       LDX  #SAVE       STA  $C9E0     Catch basic entering SAVE command       STA  $C9E1       LDX  #LOAD       STA  $CA48     Catch basic entering LOAD command       STX  $CA49        LDX  #ON       STA  $AF63       STX  $AF64**This puts syntax errors for all the lowres graphics commands*since I put the program where they used to be... *       LDX  #LINE       STX  $81FC       LDY  #$81FE       LDX  #SNERR       LDB  #13GRFX1  STX  ,Y++       DECB       BNE  GRFX1                     ** This keeps program from interrupting when multibasic loads  *       LDD  #$FFFF    See if in direct mode       CMPD CURLIN    and don't move pointer if so       BEQ  EXEC3       LDD  #HIMEM    Move basic's input pointer up with program       SUBD TXTTAB       ADDD CHARAD       STD  CHARAD*EXEC3  LDX  #CLOSE    Install close file patch       STX  $A42E        LDX  $CAC7     * This just make basic readdress program before       LDY  $CAD0     * closing file after load so extended load will work        STX  $CAD0     * (Switches the order of two subroutine calls)       STY  $CAC7     *       LDX  #LOMEM+$2600       STX  FRETOP    This protects 24576-32767 where modules load       LDX  #HIMEM-2  and clears the rest for variable use.       STX  MEMSIZ       LDX  #LOMEM       STX  VARTAB       LDX  #HIMEM    Program start in protected memory       STX  TXTTAB*       TST  $E7       See if in HiRes screen       BEQ  CLS1      Branch if not       JSR  $F6E0     Do a HiRes CLS       BRA  PRINTCLS1   JSR  $A928     Do a LowRes CLS*PRINT  LDX  #IDMSG    Print the messagePRINT1 LDA  ,X+       * get character       BEQ  RESET     * stop printing if a zero        JSR  [$A002]   * else print it       BRA  PRINT1    * and get the next one*RESET  LDX  #FCERR    Make EXEC pointer ?FC Error so       STX  EXECJP    * addition EXEC won't crash program*       LDB  #1       STB  MODNUM        JSR  SWITCH    Start in module 1       JSR  $AD26     Reset variables       JMP  $AD9E     Return to basic*IDMSG  FCC  ' MultiBasic V1.0 by Terry Todd',13       FCC  '     Copyright (C) 1990 by',13       FCC  '       Sub-Etha Software',13       FCC  '        P.O. Box 152442',13       FCC  '      Lufkin, Texas 75915',13       FCC  '     (409) 639-ETHA [3842]',13       FCB  13       FCC  '        Serial # 000042',13       FCB  13       FCB  0** The following two patches are needed for the routine that reserves the FCBS* to work with the new memory setup (Part of FILES command)*       ORG  $D1C4       SUBD #2       NOP       NOP*       ORG  $D1E2       STX  VARTAB       BRA  $D21B*       ORG  $928F  *SAVE   CMPA #'M       See if SAVEM       PSHS CC        Save flag       BNE  SAVE1     Branch if not       JSR  GETNCH    Else get the M out of the waySAVE1  JSR  GETCCH    Get current input character        BCC  SAVE2     Branch if non-numeric, not extended        JSR  $B70B     Else get number in B        JSR  SWITCH    switch in module       JSR  $B26D     do syntax check for commaSAVE2  PULS CC        Get back SAVEM flag       BEQ  SAVE3     branch if SAVEM       JMP  $C9E6     else return to Basic's SAVE routineSAVE3  JSR  $CFBB     Get filename etc.       JSR  GETCCH    get current input character       BEQ  SAVE4     Branch if end of line       JMP  $CF6C     Else return to Basic's SAVEM routine, get SE&E addressesSAVE4  LDX  TXTTAB    Get program beginning       PSHS X       LDX  NEWVAR    Get program end       PSHS X       LDX  #0        0 execution address       PSHS X       JMP  $CF7B     Return to basic's SAVEM routine*LOAD   CMPA #'M       See if LOADM       PSHS CC        Save flag       BNE  LOAD1     Branch if not       JSR  GETNCH    Else get M out of the wayLOAD1  JSR  GETCCH    Get current input character       BCC  LOAD2     Branch if non-numeric, not extended       JSR  $B70B     Else get number in B       JSR  SWITCH    Switch in module       JSR  $B26D     do syntax check for commaLOAD2  PULS CC        Get back LOADM flag       BNE  LOAD3     Branch if not LOADM       JMP  $CFC3     Jump to basic's LOADM command LOAD3  JMP  $CA4E     Jump to basic's LOAD command*CLOSE  TST  DEVNUM       LBLE $8286          PSHS D,X,U       LDB  MODNUM       JSR  SWITCH       PULS D,X,U       JMP  $CAFF*LIST   PSHS A       JSR  $AF67     Get beginning linenumber in BINVAL       LDX  BINVAL    load it in X       STX  VD1       Store in scratchpad variable until after switch       PULS B         Pull first character after LIST       TSTB       BEQ  LIST2     Branch if no argument       JSR  GETCCH    Else see if single linenumber argument       BEQ  LIST4     and branch if so       CMPA #$AC      else check for minus token       BEQ  LISTA     and branch if so       CMPB #$AE       BEQ  LIST1       BRA  LIST3  LISTA  JSR  GETNCH    See if no ending linenumber       BEQ  LIST2     branch if so       CMPA #$AE      See if extended without end linenumber       BEQ  LIST1     Branch if so       JSR  GETCCH       JSR  $AF67     Get ending line number       BEQ  LIST4     Branch if end of line       BRA  LIST3LIST1  BSR  LISTSW    get module argument and switch overLIST2  LDU  #$FFFF    default highest linenumber       STU  BINVAL       FCB  SKP2LIST3  BSR  LISTSW    else get module argument and switch overLIST4  LDD  VD1       Get beginning linenumber back       JSR  $AD03     Find it's address       STX  LSTTXT    And store in LSTTXT       JMP  $B789     return to basic*LISTSW LDB  #$AE      Syntax check for slash       JSR  $B26F       JSR  $B70B     Evaluate module number into B              JSR  SWITCH    Switch over       RTS*LISTX  LDB  MODNUM       JSR  SWITCH       JMP  $AC73*GO     JSR  GETNCH    Get next input character       CMPB #$A5      Check if "TO" Token       BEQ  GOTO      Skip sub routine if so       CMPB #$A6      Check if "SUB" Token       LBNE SNERR     Syntax error if not       LDD  #3        * Make sure there's       JSR  $AC33     * 6 Bytes on the stack       LDU  CHARAD    Current Location       LDX  CURLIN    Current Line       LDB  MODNUM    Current Module Number       LDA  #$A6      Sub Token        PSHS A,B,X,U   All put on stackGO1    BSR  GOTO      Then treat like a Goto       JMP  $AD9E     And return to basic *GOTO   JSR  GETCCH    Get current input character       JSR  $AF67     Get line number binary in BINVAL       JSR  GETCCH    Get current input character       BEQ  NOSWIT    Branch if end of line-- No extended command       LDB  #$AE      Syntax check for slash       CMPB [CHARAD]       BNE  NOSWIT* At this point, an extended command was entered       JSR  GETNCH    Get the slash       JSR  $B70B     Get module number in B       STB  VD1       Save module number in scratchpad variable       JSR  SWITCH    Switch to the module       LDD  BINVAL    Get line number to GOTO in D       BNE  MOVE      moduled goto to line 0 returns to direct mode       LDB  VD1       Get module number       STB  MODNUM    And store it       JSR  $AD33     Reset stack, string stack, continue pointer       JMP  $AC73     jump into direct mode* At this point, no extended command was entered.NOSWIT LDB  MODNUM    get current module number       STB  VD1       and store it in scratchpad variable       JSR  $AEEB     advance basic's pointer to end of line       LEAX 1,X       move to start of next line       LDD  BINVAL    Get line number to GOTO       CMPD CURLIN    Compare to current line        BHI  MOVE1     Branch if higher*MOVE   LDX  TXTTAB    Go to very beginning of programMOVE1  JSR  $AD05     Find the line        BCC  MOVE2     Branch if line found       LDB  MODNUM    *Else get back calling module number       JSR  SWITCH    *switch it back in       BRA  ULERR     *and do UL ErrorMOVE2  LDB  VD1       Successful GOTO, get back module number       STB  MODNUM    and store it        LEAX -1,X       STX  CHARAD       RTS*ON     BEQ  ONRET     Return if comma       CMPA #$AE      See if an extended linenumber (slash token)       BEQ  ON1       Branch if not        PULS B,PC      Else ON command is overON1    JSR  GETNCH       LDB  FPA0+3       PSHS B       JSR  $B70B     Get the module argument out of the way       PULS B       STB  FPA0+3       ONRET  JMP  $AF54     Go back to basic's ON routine *RUN    JSR  $AD26     Erase all variables       JMP  GO1*SWITCH TSTB           Module number in B           BEQ  FCERR     ?FC Error if module #0        CMPB MODULE    Make sure it's not too big        BHI  FCERR     and ?FC error if it is       LDX  #MODULE   Otherwise get block number from the table and switch in       ABX            * Add B to X, point X at block B         LDA  ,X        * Get block number        STA  BLKNUM    * Switch it in       STA  BLKNM2    *   "    "  "        LDX  TXTTAB    Search for end of program in hi memory  SWTCH2 TFR  X,U       * Put next line address pointer in U       LDX  ,U++      * Get address of next line, move U past pointer        BNE  SWTCH2    * If not end of program, keep going       STU  NEWVAR    * else store location of end of programSWTCH3 RTS*FCERR  LDB  #4*2       BRA  ERROMERR  LDB  #6*2       FCB  SKP2ULERR  LDB  #7*2ERR    JMP  $AC46*RETURN PULS A,B,X,U       STX  CURLIN       STU  CHARAD       STB  MODNUM       JSR  SWITCH       JSR  $AEE8       STX  CHARAD       RTS*INMSG  LDX  #$ABE8-1       JSR  $BDC8       LDX  #MODMSG-1       JSR  $B99C       CLRA       LDB  MODNUM        JMP  $BDCCINMSG1 RTS*LINE   CMPA #$89      check for input token       BNE  LINE1        JMP  $89C0     do lineinput if soLINE1  JMP  SNERR     else ?SN Error *RAMCHK BSR  RAMCK1           JMP  $AC20*RAMCK1 CMPD TOPRAM       BHS  OMERR       RTS*MODMSG FCC  ' IN MODULE '       FCB  0 *MODULE FCB  7         This is the Max # of modules       FCB  59        * This is       FCB  48        * the table       FCB  49        * of memory       FCB  50        * blocks which       FCB  51        * correspond to       FCB  55        * the module  *      FCB  52        * numbers       (Note: This module off-limits!)       FCB  1,2,3,4,5,6,7,8       FCB  9,10,11,12,13,14,15,16       FCB  17,18,19,20,21,22,23,24       FCB  25,26,27,28,29,30,31,32       FCB  33,34,35,36,37,38,39,40       FCB  41,42,43,44,45,46,47       END  EXEC