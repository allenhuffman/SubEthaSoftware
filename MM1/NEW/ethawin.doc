
     ---------------------------------------------------------------------
     EthaWin Text-Based Interface by Allen C. Huffman of Sub-Etha Software
     ---------------------------------------------------------------------
 
 
Library Functions
-----------------
 
   Most functions of the EthaWin library are for internal system use.  The
core of the library is made up of a Startup() function which initializes the
interface, and a CheckMenu() routine which handles all the necessary menu
processing and returns appropriate option, menu, mouse or keyboard information
to the user's program.  A few other various functions, such as PrintAt() and
LineInput() are also provided.  For convienence all user functions are
predeclared in ethawin.h.


   #include <ethawin.h>
   #include <ethaglobals.h>

   int Startup(makewin, maxmenus)
   char makewin;
   int  maxmenus;
 
   If "makewin=TRUE", Startup() will open a new window and select it for the
application to operate from.  If "makewin=FALSE", the existing screen is used
and *MUST* be an 80 column window (no checking is done).  This was provided to
allow EthaWin applications to run over terminals supporting OS9 screen codes. 
In either case, the path to the new window is returned.
   The parameter maxmenus is the number of menus that will be used for the
application being started.  This is used to allocate memory for various arrays
that are used to deal with the menus.
   The Startup() routine sets up an Intercept trap for keyboard and mouse
signals, modifies tmode settings appropriately (no echo), and attempts to read
user settings (ReadCfg) from the file "/DD/SYS/ETHAWIN/ethawin.cfg".  Defaults
will be used if this file does not exist.  Screen colors and initial menu and
title bar is created (title text can be added using the TopText function).


   #include <ethawin.h>
   #include <ethaglobals.h>

   int ShutDown(wpath)
   int wpath;
 
   This function is the opposite of StartUp and will restore terminal
settings and kill the created window (if any).


   #include <ethawin.h>
   #include <ethaglobals.h>

   TopText(wpath,left,title,right)
   int wpath;
   char *left,*title,*right;
 
   This function allows you to display text on the title bar.  The EthaWin
standard is for the application name, version number, and author to appear as
the "title".  The "left" and "right" text have not been defined.
 
   Example:    TopText(wpath,"","Towel V1.01 - By Allen Huffman","");
 
 
   LineInput(wpath,x,y,prompt,line,length)
   int wpath,x,y;
   char *prompt,*line;
   int length;
 
   This is a general purpose input routine.  Pass it the window path and the X
and Y coordinates (0-79, 0-23) for the "prompt" (if any) to appear, and it
will accept a string in "line" of "length" characters from the user.  If ENTER
is chosen by the user, "line" will be a NULL character.  If "length==1", it
works like Inkey$.  One character will be chosen without ENTER needing to be
pressed and it will be made uppercase.
 
   Example:    LineInput(wpath,10,10,"Name:",line,25);
 
 
   PrintAt(wpath,x,y,text)
   int wpath,x,y;
   char *text;
 
   A general purpose print routine that displays "text" at the X and Y
position on the screen.
 
 
   #include <ethawin.h>
   #include <ethaglobals.h>

   int YesNo(wpath,title) /* are you sure box */
   int wpath;
   char *title;
 
   A nifty dialog box that accepts either YES or NO from the user.  "title"
can be a short (26 characters or less) box title.  The routine will return
TRUE if YES was selected or FALSE if no selected.
 
   Example:    if ( YesNo(wpath,"QUIT?") == TRUE ) ShutDown();
 
 
   #include <ethawin.h>
   #include <ethaglobals.h>

   PopUp(wpath,title,x,y,w,h) /* pop-up shaded dialog box... */
   int wpath;
   char *title;
   int x,y,w,h;
 
   This one is tricky.  It creates a pop-up window with "title" starting at X
and Y, with the width of W and height of H.  Working area is changed into this
window, and you can use PrintAt to put text there.  The usable portion of the
window is w-2 x h-2 (1 character from the left side, 1 from the right, 1 line
from the top and 1 line from the bottom).  When done, you must use EndWin to
close this double window.
 
   Example:    PopUp(wpath,"NotePad",10,10,60,8);
 
 
   EndWin(wpath) /* kill overlay window */
   int wpath;
 
   This kills windows created with PopUp by performing two overlay window end
calls.  Simple.
 
 
   #include <ethawin.h>
   #include <ethaglobals.h>

   Wait(wpath)
   int wpath;
 
   A multi-purpose pause routine.  It will wait for a keypress or mouse click,
then return to the program.  Use this in conjunction with PopUp if you are
just displaying a warning message, for instance.
 
 
   #include <ethawin.h>
   #include <ethaglobals.h>

   Snooze(wpath)
   int wpath;
 
   This checks to see if the mouse pointer is valid (ie, is the program on an
active window or in the background?) and puts the program to sleep if it's
not.  This is actually called within the CheckMenu routine, but I include it
here in case it may be of other use.
 

   #include <ethawin.h>
   #include <ethaglobals.h>

   error(wpath, title, message1, message2, error_code)
   int wpath; /* window path */
   char *title; /* title of message window */
   char *message1; /* first part of error message */
   char *message2: /* second part of error message */
   int error_code; 

   This function pops up a 40x4 overlay window and prints message1 followed by
message2 (no newline is added between strings), followed by a newline, then
the string "Error # " followed by the value of error_code.  The function then
waits for the user to press a key or click the mouse button.
   The function is usefull for explaining errors that occur in a program,
error_code is usually the value of the global variable errno.


   int OpenFile(filename,mode)
   char filename[];
   int mode;
 
   This is the OS9 "open" call.  Pass it the "filename" string of a file or
device and the access "mode" byte (S_IWRITE, etc.) and it will return the path
to the file/device or ZERO if it was unable to open.  Be sure to
"Close(fpath)" when done.


   char *getpwd()

   This function returns a pointer to a null terminated string that contains
the complete pathlist to the current data directory.  The string returned
points to static storage and will be overwitten for each call.  If the caller
wishes to save the string it should copy it into a local variable.  If there
is an error then it returns NULL and the error code is given by the global
variable errno.


   char *getspwd(dir_name)
   char *dir_name; /* name of current directory */

   This function gets the name of the current data directory - ie DATA,
and places it in dir_name, a pointer to this string is returned.  If there
is an error then NULL is returned and dir_name will be empty.


   #include <ethawin.h>
   #include <ethaglobals.h>

   int makeButton(wpath, blist, button_number, button_name, posx, posy)
   int wpath; /* window path */
   struct BUTTON *blist; /* pointer to button list */
   int button_number; /* the position of the button in the buttonlist */
   char *button_name; /* the name of the button */
   int posx; /* the x position of the button */
   int posy; /* the y position of the button */

   int checkButton(blist, number_of_buttons)
   struct BUTTON *blist;
   int number_of_buttons; /* the total number of buttons in the list */

   activateButton(wpath, blist, button_number)
   int wpath;
   struct BUTTON *blist;
   int button_number; /* the number of the button to activate */

   deactivateButton(wpath, blist, button_number)
   int wpath;
   struct BUTTON *blist;
   int button_number; /* the number of the button to deactivate */

   redrawButtons(wpath, blist, number_of_buttons)
   int wpath;
   struct BUTTON *blist;
   int number_of_buttons; /* total number of button in list */


   makeButton() - adds the button information given to the button list pointed
to by blist.  The button list must exist before calling makebutton.  An easy
way to do this is to declare the button list as an array of BUTTON's.  This
way button_number can corespond to the array index of the corresponding button
(see the example below).  If the button name is longer than BUTTONNAMELEN 
(defined in ethawin.h) the name is truncated.
   When the button is created it is active and it is displyed on wpath in
reverse video.
   The function returns 1, although this may change in the future.

   checkButton() - checks the buttons stored in blist to see if the user
clicked on an active button.  The button number clicked on is returned if a
button was selected, -1 is returned otherwise.

   activateButton() - activates the button given by button_number.  This
entails writting the button name in reverse video.

   deactivateButton() - deactivates the button given by button_number.  This
entails writting the button name in normal video.

   redrawButtons() - redraws all the buttons in blist.  If the button is
active it is written in reverse video, otherwise it is written in normal
video.


   #include <ethawin.h>
   #include <ethaglobals.h>

   char *EwFPick(wpath, title, types)
   int wpath;
   char *title;
   int types; /* types of files to display */

   This is a file picking function.  It pops up an overlay window with a list
of the files in the current directory that match at least those attributes
given by types.  The user can scroll up and down the list of files or choose
one of several options.  To select a file the user highlights the filename
by clicking on either the 'Up' or 'Down' buttons (or using the arrow keys),
the currently selected file appears in reverse video.  Once the desired file
is highlighted the user may either click on the 'Okay' button or press <Enter>.
The other button options are listed below.  A pointer to the name of the file
selected is returned (this can be either a file or directory name).  The
pointer points to static storage and is overwritten each time EwFPick() is
called.  If the user clicks on the 'Cancel' button or presses <Break> then
the string returned is empty.  If there is an error then NULL is returned and
the error code can be found in errno.
   The list of files displayed is controlled by the types parameter.  The value
of types is determined by or'ing the desired attributes together, the
attributes are defined in ethawin.h.  For example if types equals OREAD then
all the files in the current data directory that have the owner readable 
attribute set will be listed (except for directories).
   If DIRECTORY is or'ed into types then only directories with the proper
attributes will be listed.  For example if types equals DIRECTORY | OREAD then
only those directories that readable by the current user will be listed.
   Two special values are defined.  The first is ALLFILES, if types equals
ALLFILES then all the files in the directory (including subdirectories) will
be listed iregaurdless of their attributes.  Next is BOTH if BOTH is or'ed
into types - ie BOTH | OREAD, then both files and subdirectories will be
listed, but only those those that match at least the attributes specified (
owner readable in the above example).
   The other button options available are;

        Drive       - change to a new drive, the user is asked to specify
                        the drive name.
        Parent      - change to the current directory's parent, the only
                        way to return to the original directory is if
                        directories are listed (either DIRECTORY or BOTH
                        have been or'ed into types).
        Open        - open the directory highlighted in the file list 
                        (this button is only active when the current filename
                         is a directory).
        NewFolder   - creates a new directory in the current one and changes
                        to it.
        NewFile     - asks the user to specify the name of the new file, the
                        function then returns the name given if it does not
                        already exist.  The current directory is changed to
                        the one in which the newfile resides.
        Cancel      - cancels the current call (function returns NULL).  The
                        current directory is returned to the directory that
                        was the current directory when EwFPick() was called.
        Okay        - selects the current filename (or directory name) and
                        returns a pointer to it.  The current directory is
                        changed to the one in which the file resides.

NOTE:  This is a rather large function, if your application does not already
       use buttons or getpwd(), it will add approximately 6.5 K to the
       application.  Using buttons and the getpwd() function add approximately
       1 K each, so if your application already uses buttons and getpwd() then
       EwFPick() will only add approximately 4.5 K.


   #include <ethawin.h>
   #include <ethaglobals.h>

   char checkMouse(wpath, repeat)
   int wpath;
   char repeat; /* flag fro mouse button repeat */

   This function is called by CheckMenu() (see below) to update the mouse
position and to check to see if the mouse button has been pressed.  If
"repeat=TRUE" then holding down the mouse button is the same as repeatedly
clicking it.  This function is listed here for those instances in which an
application needs to check the mouse status, but does not need to check
to see if a menu was selected (EwFPick() above uses this function).


* NOTE:  Complex Menu Handling Routines Follow...
 
 
   #include <ethawin.h>
   #include <ethaglobals.h>

   char CheckMenu(wpath,menu,option,ch,click,repeat)
   int wpath,*menu,*option;
   char *ch; /* pointer to character read, if any... */
   char *click; /* returned status of mouse click */
   char repeat; /* flag for mouse button repeat */
 
   This is the core of EthaWin.  This routine needs to be the main loop of any
EthaWin program.  Pass CheckMenu the POINTER to menu and option integers, and
ch and click chars and it will return values in them, if available.  If
nothing was received (no menu selected, no key pressed, no mouse status),
CheckMenu returns FALSE.
   If TRUE, "menu" will be the menu selected (0-XX) and "option" will be the
option chosen within that menu (0-XX) as defined in the ...vars.c file for
your program.
   If "repeat=TRUE", then holding the mouse button down is the same as
repeatedly clicking the mouse button.

   Long Example:
 
   int menu,option;
   char ch,click;
 
   if CheckMenu(wpath,&menu,&option,&ch,&click) { /* if something there, */
      if (menu==0) { /* if, say, FILE menu chosen: */
         ...blah blah blah to check for what "option" was chosen
            and run whatever routine it should run...
      }
   }
 
   If nothing was chosen, you may still see if any keys were pressed by
checking "ch" or see if the mouse was clicked by checking "click".  Thus, you
could still have "hot-keys" of your own or check for screen hot spots.  Please
see the sample source for for the "ethademo.c" for more information.
   All global mouse information is available to your program after this call
from the global variables "mouse_x" and "mouse_y".  Thus, after a CheckMenu
you might say:
 
   if (click==TRUE) { /* click detected */
      if (mouse_y == 3) { /* mouse click on line 3, which has a button */
         if (mouse_x>5 && mouse_y<10) {
            ...activate that button...
         }
      }
   }
 
   ...or whatever.  I realize this isn't very clear, but perhaps it will make
sense when you see the demo source.
 
 
   That should cover the functions of the library.  Please see the
"ethademovars.c" file for detailed information on setting up the menu text in
the global variables.
 
 
   Good luck!  For questions, contact "coco-sysop@genie.geis.com".
 
                                                -- Allen C. Huffman, 12/14/94
                                                -- Chris Hyde, 3/28/95
